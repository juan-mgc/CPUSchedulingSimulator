<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>CPU Scheduling Simulator</title>
    <style>
      :root {
        --primary-color: #4361ee;
        --primary-hover: #3a56d4;
        --secondary-color: #f72585;
        --background-light: #f8f9fa;
        --text-dark: #212529;
        --text-light: #6c757d;
        --border-color: #dee2e6;
        --success-color: #4cc9f0;
        --card-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        --transition: all 0.3s ease;
      }
      body {
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        line-height: 1.6;
        color: var(--text-dark);
        background-color: #f5f7fa;
        max-width: 1200px;
        margin: 0 auto;
        padding: 2rem;
      }
      h1 {
        color: var(--primary-color);
        text-align: center;
        margin-bottom: 2rem;
        font-weight: 600;
        font-size: 2.2rem;
      }
      .controls {
        background: white;
        padding: 1.5rem;
        border-radius: 10px;
        box-shadow: var(--card-shadow);
        margin-bottom: 2rem;
        display: flex;
        flex-wrap: wrap;
        gap: 1rem;
        align-items: center;
      }

      .control-group {
        display: flex;
        align-items: center;
        gap: 0.5rem;
      }

      label {
        font-weight: 500;
        color: var(--text-dark);
        white-space: nowrap;
      }

      button {
        padding: 0.6rem 1.2rem;
        background-color: var(--primary-color);
        color: white;
        border: none;
        border-radius: 6px;
        cursor: pointer;
        font-weight: 500;
        transition: var(--transition);
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        display: inline-flex;
        align-items: center;
        gap: 0.5rem;
      }

      button:hover {
        background-color: var(--primary-hover);
        transform: translateY(-1px);
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
      }

      .example-buttons {
        display: flex;
        gap: 1rem;
        margin-bottom: 1rem;
      }

      table {
        width: 100%;
        border-collapse: separate;
        border-spacing: 0;
        margin-bottom: 2rem;
        background: white;
        border-radius: 10px;
        overflow: hidden;
        box-shadow: var(--card-shadow);
      }

      th {
        background-color: var(--primary-color);
        color: white;
        padding: 1rem;
        text-align: left;
        font-weight: 600;
      }

      td {
        padding: 0.8rem 1rem;
        border-bottom: 1px solid var(--border-color);
      }

      tr:last-child td {
        border-bottom: none;
      }

      input[type="number"] {
        width: 80px;
        padding: 0.5rem;
        border: 1px solid var(--border-color);
        border-radius: 4px;
        transition: var(--transition);
      }

      .results {
        background: white;
        padding: 1.5rem;
        border-radius: 10px;
        box-shadow: var(--card-shadow);
        margin-top: 2rem;
      }

      .cpu-timeline {
        margin-top: 1rem;
        padding: 1rem;
        background: #f8f9fa;
        border-radius: 6px;
      }

      .cpu-header {
        font-weight: bold;
        margin-bottom: 0.5rem;
        color: var(--primary-color);
      }

      .cpu-execution {
        display: flex;
        flex-wrap: wrap;
        gap: 0.5rem;
      }
      .timeline-container {
        position: relative;
        margin-top: 20px;
      }
      .timeline-ticks {
        display: flex;
        margin-left: 80px;
        position: relative;
        height: 20px;
        margin-top: 30px; /* Move ticks below CPU bars */
      }
      .tick {
        position: absolute;
        top: 0; /* Position below CPU bars */
        transform: translateX(-50%);
        height: 10px;
        width: 1px;
        background: #333;
      }
      .tick-label {
        position: absolute;
        top: 100%;
        transform: translateX(-50%);
        font-size: 0.8em;
        white-space: nowrap;
        background: white;
        padding: 0 2px;
        z-index: 10;
      }
      .cpu-bar {
        position: relative;
        margin-bottom: 5px; /* Space between CPU bars and ticks */
      }
      .segment-end {
        position: absolute;
        bottom: -15px; /* Position above ticks */
        height: 5px;
        width: 1px;
        background: #333;
      }
      .cpu-row {
        margin-bottom: 5px; /* Less space between CPU rows */
      }
      .time-segment {
        background: var(--primary-color);
        color: white;
        padding: 0.3rem 0.6rem;
        border-radius: 4px;
        font-size: 0.9rem;
      }

      .error-message {
        color: #dc3545;
        font-size: 0.9rem;
        margin-top: 0.5rem;
      }
      .time-block.idle {
        background-color: #e0e0e0;
        color: #333;
      }

      @media (max-width: 768px) {
        body {
          padding: 1rem;
        }
        .controls {
          flex-direction: column;
          align-items: stretch;
        }
        .control-group {
          flex-direction: column;
          align-items: flex-start;
        }
        .example-buttons {
          flex-direction: column;
        }
      }
    </style>
  </head>
  <body>
    <h1>CPU Scheduling Simulator</h1>

    <div class="example-buttons">
      <button onclick="loadExample1()">Load Example 1</button>
      <button onclick="loadExample2()">Load Example 2</button>
    </div>

    <div class="controls">
      <div class="control-group">
        <label for="cpuCount">Number of CPUs:</label>
        <input type="number" id="cpuCount" min="1" value="2" step="1" />
      </div>

      <div class="control-group">
        <label for="timeQuantum">Time Quantum:</label>
        <input type="number" id="timeQuantum" min="0.1" value="1" step="0.1" />
      </div>

      <div class="control-group">
        <label for="srtnMode">SRTN Mode:</label>
        <select id="srtnMode">
          <option value="immediate">Immediately Continue Switch</option>
          <option value="quantum">Quantum Wait</option>
        </select>
      </div>

      <button onclick="addJob()">Add Job</button>
      <button onclick="removeLastJob()">Remove Last Job</button>
      <button onclick="calculateSRTN()">Calculate SRTN</button>
      <button onclick="calculateRoundRobin()">Calculate Round Robin</button>
    </div>

    <table id="jobTable">
      <thead>
        <tr>
          <th>Job</th>
          <th>Arrival Time</th>
          <th>Burst Time</th>
          <th>Start Time</th>
          <th>End Time</th>
          <th>Turnaround Time</th>
        </tr>
      </thead>
      <tbody>
        <!--jobs will be added here with the code-->
      </tbody>
    </table>

    <div id="results" class="results" style="display: none">
      <h3>Results</h3>
      <div id="averageTurnaroundTime"></div>
      <div id="executionTimeline"></div>
    </div>

    <script>
      //global variables to track jobs and next job ID
      let jobs = [];
      let nextJobId = 1;

      //function to add a new job with default values
      function addJob() {
        const newJob = {
          id: nextJobId++,
          arrivalTime: 0,
          burstTime: 1,
          remainingTime: 1,
          startTime: -1, //job hasn't started yet
          endTime: 0, //job hasn't finished yet
          turnaroundTime: 0, //to be calculated when job completes
          lastExecutionTime: -1, //tracks when job was last assigned to CPU
          inQueue: false, //tracks if job is currently in waiting queue
        };
        jobs.push(newJob);
        updateJobTable();
      }

      //function to remove the last job from the list
      function removeLastJob() {
        if (jobs.length > 0) {
          jobs.pop();
          //reset nextJobId to be one more than the highest existing ID
          nextJobId =
            jobs.length > 0 ? Math.max(...jobs.map((j) => j.id)) + 1 : 1;
          updateJobTable();
        }
      }

      //update the job table in the UI
      function updateJobTable() {
        const tableBody = document.querySelector("#jobTable tbody");
        tableBody.innerHTML = "";

        //create a row for each job with editable arrival and burst times
        jobs.forEach((job, index) => {
          const row = tableBody.insertRow();
          row.innerHTML = `<td>J${job.id}</td>
                          <td><input type="number" value="${
                            job.arrivalTime
                          }" min="0" step="0.1" onchange="validateNumberInput(this); updateJobProperty(${index}, 'arrivalTime', this.value)"></td>
                          <td><input type="number" value="${
                            job.burstTime
                          }" min="0.1" step="0.1" onchange="validateNumberInput(this); updateJobProperty(${index}, 'burstTime', this.value)"></td>
                          <td>${
                            job.startTime === -1
                              ? "-"
                              : job.startTime.toFixed(1)
                          }</td>
                          <td>${
                            job.endTime === 0 ? "-" : job.endTime.toFixed(1)
                          }</td>
                          <td>${
                            job.turnaroundTime === 0
                              ? "-"
                              : job.turnaroundTime.toFixed(1)
                          }</td>`;
        });
      }

      //validate numeric inputs
      function validateNumberInput(input) {
        if (isNaN(input.value) || input.value === "") {
          input.value = input.min || 0;
          showError("Please enter a valid number");
        }
      }

      //display error messages temporarily
      function showError(message) {
        const errorDiv = document.createElement("div");
        errorDiv.className = "error-message";
        errorDiv.textContent = message;
        document.body.appendChild(errorDiv);
        setTimeout(() => errorDiv.remove(), 3000);
      }

      //update job properties with validation
      function updateJobProperty(index, property, value) {
        const numValue = parseFloat(value);
        if (isNaN(numValue)) {
          showError("Invalid number entered");
          return;
        }
        jobs[index][property] = numValue;

        //if burst time changes, update remaining time as well
        if (property === "burstTime") {
          jobs[index].remainingTime = numValue;
        }
      }

      //to load the first example set of jobs
      function loadExample1() {
        document.getElementById("cpuCount").value = 2; //2 CPUs
        document.getElementById("timeQuantum").value = 1; //quantum of 1
        jobs = [
          {
            id: 1,
            arrivalTime: 0,
            burstTime: 4,
            remainingTime: 4,
            startTime: -1,
            endTime: 0,
            turnaroundTime: 0,
            lastExecutionTime: -1,
            inQueue: false,
          },
          {
            id: 2,
            arrivalTime: 0.5,
            burstTime: 2,
            remainingTime: 2,
            startTime: -1,
            endTime: 0,
            turnaroundTime: 0,
            lastExecutionTime: -1,
            inQueue: false,
          },
          {
            id: 3,
            arrivalTime: 1,
            burstTime: 6,
            remainingTime: 6,
            startTime: -1,
            endTime: 0,
            turnaroundTime: 0,
            lastExecutionTime: -1,
            inQueue: false,
          },
          {
            id: 4,
            arrivalTime: 1,
            burstTime: 1.5,
            remainingTime: 1.5,
            startTime: -1,
            endTime: 0,
            turnaroundTime: 0,
            lastExecutionTime: -1,
            inQueue: false,
          },
        ];
        nextJobId = 5;
        updateJobTable();
      }

      //load the second example set of jobs
      function loadExample2() {
        document.getElementById("cpuCount").value = 2; //2 CPUs
        document.getElementById("timeQuantum").value = 1; //quantum of 1
        jobs = [
          {
            id: 1,
            arrivalTime: 0,
            burstTime: 4,
            remainingTime: 4,
            startTime: -1,
            endTime: 0,
            turnaroundTime: 0,
            lastExecutionTime: -1,
            inQueue: false,
          },
          {
            id: 2,
            arrivalTime: 1,
            burstTime: 2,
            remainingTime: 2,
            startTime: -1,
            endTime: 0,
            turnaroundTime: 0,
            lastExecutionTime: -1,
            inQueue: false,
          },
          {
            id: 3,
            arrivalTime: 1,
            burstTime: 6,
            remainingTime: 6,
            startTime: -1,
            endTime: 0,
            turnaroundTime: 0,
            lastExecutionTime: -1,
            inQueue: false,
          },
          {
            id: 4,
            arrivalTime: 2,
            burstTime: 3,
            remainingTime: 3,
            startTime: -1,
            endTime: 0,
            turnaroundTime: 0,
            lastExecutionTime: -1,
            inQueue: false,
          },
        ];
        nextJobId = 5;
        updateJobTable();
      }
      ///////////////////////////
      function calculateSRTN() {
        //input values
        const cpuCountInput = document.getElementById("cpuCount");
        const quantumInput = document.getElementById("timeQuantum");
        const srtnMode = document.getElementById("srtnMode").value;
        //validate CPU input
        if (isNaN(cpuCountInput.value) || cpuCountInput.value < 1) {
          showError("Invalid number of CPUs - must be at least 1");
          return;
        }
        //validate quantum input
        if (isNaN(quantumInput.value) || quantumInput.value <= 0) {
          showError("Invalid time quantum - must be greater than 0");
          return;
        }

        const cpuCount = parseInt(cpuCountInput.value);
        const timeQuantum = parseFloat(quantumInput.value);
        //check if there are jobs to schedule
        if (jobs.length === 0) {
          showError("No jobs to schedule - please add jobs first");
          return;
        }

        //reset all job states before starting simulation
        jobs.forEach((job) => {
          job.remainingTime = job.burstTime;
          job.startTime = -1; //job didnt start
          job.endTime = 0;
          job.turnaroundTime = 0;
          job.lastExecutionTime = -1; //last run
          job.inQueue = false; //jobs in ready queue
        });

        let currentTime = 0; //current time
        let completedJobs = 0; //count for completed jobs
        let runningJobs = new Array(cpuCount).fill(null); //jobs on cpus
        let jobQueue = [];
        let cpuTimelines = new Array(cpuCount).fill().map(() => []); //timeline for each cpu
        let lastExecutionTimes = new Array(cpuCount).fill(null); // last started job per cpu
        let queueStates = {}; //queue state for each time

        //main loop
        while (completedJobs < jobs.length) {
          //job arrivals at current time
          jobs.forEach((job) => {
            if (
              //check if job has arrived and didint complete, also not in queue
              job.arrivalTime <= currentTime &&
              job.remainingTime > 0 &&
              !job.inQueue &&
              !runningJobs.includes(job)
            ) {
              jobQueue.push(job);
              job.inQueue = true;
            }
          });

          //sort queue by SRTN priority
          jobQueue.sort((a, b) => {
            if (a.remainingTime === b.remainingTime) {
              //in case of tie, use arrival time for priority
              return a.arrivalTime - b.arrivalTime;
            }
            return a.remainingTime - b.remainingTime;
          });

          //queue state at current time
          queueStates[parseFloat(currentTime.toFixed(1))] = {
            queue: [
              ...jobQueue.map((job) => ({
                id: job.id,
                remaining: job.remainingTime,
              })),
            ],
          };

          //CPU assignments
          for (let cpuIndex = 0; cpuIndex < cpuCount; cpuIndex++) {
            //logic for job if job has no remaining time
            if (
              runningJobs[cpuIndex] &&
              runningJobs[cpuIndex].remainingTime <= 0
            ) {
              const completedJob = runningJobs[cpuIndex];
              //set as completed - issues with decimals
              completedJob.endTime = parseFloat(currentTime.toFixed(1));
              completedJob.turnaroundTime = parseFloat(
                (completedJob.endTime - completedJob.arrivalTime).toFixed(1)
              );
              completedJobs++;
              //for quantum wait
              //hanldeidle time if job completed earlier than quantum unit
              if (srtnMode === "quantum") {
                //quantum end time for this CPU
                const quantumStart =
                  Math.floor(lastExecutionTimes[cpuIndex] / timeQuantum) *
                  timeQuantum;
                const quantumEnd = parseFloat(
                  (quantumStart + timeQuantum).toFixed(1)
                );

                //if job completed before quantum end
                if (currentTime < quantumEnd) {
                  //idle time segment for remaining quantum
                  cpuTimelines[cpuIndex].push({
                    start: currentTime,
                    end: quantumEnd,
                    job: null, //idle time
                    remaining: 0,
                  });

                  //mark CPU as busy until quantum ends
                  lastExecutionTimes[cpuIndex] = quantumEnd;
                }
              }

              runningJobs[cpuIndex] = null; //free cPU
            }

            // Assign new job if
            // CPU is idle &
            // there are jobs waiting &
            // (quantum mode) current time >= last execution end for this CPU
            if (
              runningJobs[cpuIndex] === null &&
              jobQueue.length > 0 &&
              (srtnMode !== "quantum" ||
                lastExecutionTimes[cpuIndex] === null ||
                currentTime >= lastExecutionTimes[cpuIndex])
            ) {
              const nextJob = jobQueue.shift();
              if (nextJob.startTime === -1) {
                nextJob.startTime = parseFloat(currentTime.toFixed(1));
              }
              runningJobs[cpuIndex] = nextJob;
              lastExecutionTimes[cpuIndex] = parseFloat(currentTime.toFixed(1));
              nextJob.inQueue = false;
            }
          }

          //current time unit - 0.1 increments for class example
          const timeIncrement = 0.1;
          for (let cpuIndex = 0; cpuIndex < cpuCount; cpuIndex++) {
            if (runningJobs[cpuIndex]) {
              const currentJob = runningJobs[cpuIndex];
              const executionStart = parseFloat(currentTime.toFixed(1));
              let executionEnd = parseFloat(
                (currentTime + timeIncrement).toFixed(1)
              );
              let remainingAfterExecution = parseFloat(
                (currentJob.remainingTime - timeIncrement).toFixed(1)
              );
              //hanlde job in case of completed during this increment
              if (remainingAfterExecution <= 0) {
                executionEnd = parseFloat(
                  (currentTime + currentJob.remainingTime).toFixed(1)
                );
                remainingAfterExecution = 0;
              }
              //record segment
              cpuTimelines[cpuIndex].push({
                start: executionStart,
                end: executionEnd,
                job: currentJob.id,
                remaining: remainingAfterExecution,
              });

              currentJob.remainingTime = remainingAfterExecution;

              //quantum expiration
              if (
                remainingAfterExecution > 0 &&
                lastExecutionTimes[cpuIndex] !== null &&
                parseFloat(
                  (executionEnd - lastExecutionTimes[cpuIndex]).toFixed(1)
                ) >= timeQuantum
              ) {
                //in case quantum expired
                jobQueue.push(currentJob);
                currentJob.inQueue = true;
                runningJobs[cpuIndex] = null;
                lastExecutionTimes[cpuIndex] = null;
              }
            }
          }

          currentTime = parseFloat((currentTime + timeIncrement).toFixed(1));
          //debugging
          if (currentTime > 1000) {
            showError("Simulation timeout - check for infinite loop");
            break;
          }
          ////////////
        }

        //job end times from execution segments
        jobs.forEach((job) => {
          let lastSegment = null;
          //find last segment for this job accross CPUs
          cpuTimelines.forEach((timeline) => {
            timeline.forEach((segment) => {
              if (
                segment.job === job.id &&
                (!lastSegment || segment.end > lastSegment.end)
              ) {
                lastSegment = segment;
              }
            });
          });

          if (lastSegment) {
            job.endTime = parseFloat(lastSegment.end.toFixed(1));
            job.turnaroundTime = parseFloat(
              (job.endTime - job.arrivalTime).toFixed(1)
            );
          }
        });

        //update UI
        updateJobTable();
        displayResults(cpuTimelines, queueStates, timeQuantum);
      }
      //////////////////////////
      //round robin scheduling algorithm
      function calculateRoundRobin() {
    //inputs with decimal support
    const cpuCount = parseFloat(document.getElementById("cpuCount").value);
    const timeQuantum = parseFloat(
      document.getElementById("timeQuantum").value
    );
    const timePrecision = 1; //min time unit (0.1 for decimal, 1 for integer)

    //inputs validation
    if (
      isNaN(cpuCount) ||
      cpuCount <= 0 ||
      isNaN(timeQuantum) ||
      timeQuantum <= 0
    ) {
      showError(
        "Invalid input: CPU count and time quantum must be positive numbers"
      );
      return;
    }

    //reset job states
    jobs.forEach((job) => {
      job.remainingTime = parseFloat(job.burstTime);
      job.startTime = -1;
      job.endTime = 0;
      job.turnaroundTime = 0;
      job.lastExecutionTime = -1;
      job.inQueue = false;
      job.quantumUsed = 0; //tracking quantum usage
    });

    let currentTime = 0;
    let completedJobs = 0;
    let runningJobs = new Array(cpuCount).fill(null); //jobs on each CPU
    let jobQueue = []; //ready queue
    let cpuTimelines = new Array(cpuCount).fill().map(() => []); //execution timeline
    let queueStates = {}; //to track queue state at each time point

    //main loop
    while (completedJobs < jobs.length) {
      //add arriving jobs to queue with decimal arrival times
      jobs.forEach((job) => {
        if (
          approximatelyEqual(job.arrivalTime, currentTime, timePrecision) &&
          job.remainingTime > 0 &&
          !jobQueue.includes(job) &&
          !runningJobs.includes(job)
        ) {
          jobQueue.push(job);
          job.inQueue = true;
        }
      });

      //record queue state at current time
      queueStates[currentTime.toFixed(2)] = {
        queue: [
          ...jobQueue.map((job) => ({
            id: job.id,
            remaining: parseFloat(job.remainingTime.toFixed(2)),
          })),
        ],
        running: [
          ...runningJobs
            .filter((job) => job !== null)
            .map((job) => ({
              id: job.id,
              remaining: parseFloat(job.remainingTime.toFixed(2)),
            })),
        ],
      };

      // Handle CPU assignments and quantum management FIRST
      for (let cpu = 0; cpu < cpuCount; cpu++) {
        const currentJob = runningJobs[cpu];

        //handle job completion/quantum expiration
        if (currentJob) {
          if (approximatelyLessThanOrEqual(
            currentJob.remainingTime,
            0,
            timePrecision
          )) {
            // Job completes
            currentJob.endTime = currentTime;
            currentJob.turnaroundTime =
              currentJob.endTime - currentJob.arrivalTime;
            completedJobs++;
            runningJobs[cpu] = null;
          } else if (approximatelyGreaterThanOrEqual(
            currentJob.quantumUsed,
            timeQuantum,
            timePrecision
          )) {
            // Quantum expires (but job not done)
            jobQueue.push(currentJob);
            currentJob.inQueue = true;
            currentJob.quantumUsed = 0; // Reset quantum counter
            runningJobs[cpu] = null;
          }
        }

        //new job to CPU if available
        if (runningJobs[cpu] === null && jobQueue.length > 0) {
          const nextJob = jobQueue.shift();
          nextJob.inQueue = false;
          nextJob.quantumUsed = 0; // Reset quantum counter

          if (nextJob.startTime === -1) {
            nextJob.startTime = currentTime;
          }

          runningJobs[cpu] = nextJob;
        }
      }

      // THEN execute jobs and update timeline
      for (let cpu = 0; cpu < cpuCount; cpu++) {
        if (runningJobs[cpu]) {
          const job = runningJobs[cpu];
          const executionTime = Math.min(
            timePrecision,
            job.remainingTime,
            timeQuantum - job.quantumUsed
          );

          //record timeline segment
          cpuTimelines[cpu].push({
            start: currentTime,
            end: currentTime + executionTime,
            job: job.id,
            remaining: parseFloat(
              (job.remainingTime - executionTime).toFixed(2)
            ),
          });

          //update job state
          job.remainingTime -= executionTime;
          job.quantumUsed += executionTime;
        }
      }

      //increment time by the minimum time unit
      currentTime += timePrecision;

      //debugging
      if (currentTime > 1000) {
        showError("Simulation timeout - check for infinite loop");
        break;
      }
    }

    //update UI
    updateJobTable();
    displayResults(cpuTimelines, queueStates, timeQuantum);
  }

      //helper functions for floating point comparisons
      function approximatelyEqual(a, b, precision) {
        return Math.abs(a - b) < precision;
      }

      function approximatelyLessThanOrEqual(a, b, precision) {
        return a < b || approximatelyEqual(a, b, precision);
      }

      function approximatelyGreaterThanOrEqual(a, b, precision) {
        return a > b || approximatelyEqual(a, b, precision);
      }

      //display results in the UI
      function displayResults(cpuTimelines, queueStates, quantum) {
        const resultsDiv = document.getElementById("results");
        resultsDiv.style.display = "block";

        //calculate average turnaround
        const turnaroundTimes = jobs.map((job) => job.turnaroundTime);
        const totalTurnaroundTime = turnaroundTimes.reduce(
          (sum, time) => sum + time,
          0
        );
        const averageTurnaroundTime = totalTurnaroundTime / jobs.length;
        //display calculation
        document.getElementById("averageTurnaroundTime").innerHTML = `
              <p><strong>Average Turnaround Time:</strong> ${turnaroundTimes.join(
                " + "
              )} / ${jobs.length} = <b>${averageTurnaroundTime.toFixed(
          2
        )}</b></p>`;

        //grouping small job segments since they are being partition by decimals
        const displayTimelines = cpuTimelines.map((timeline) => {
          const consolidated = [];
          let currentSegment = null;

          timeline.forEach((segment) => {
            //put together segments
            if (
              !currentSegment ||
              currentSegment.job !== segment.job ||
              segment.start - currentSegment.end > 0.01
            ) {
              if (currentSegment) consolidated.push(currentSegment);
              currentSegment = {
                start: segment.start,
                end: segment.end,
                job: segment.job,
                remaining: segment.remaining,
              };
            } else {
              currentSegment.end = segment.end;
              currentSegment.remaining = segment.remaining;
            }
          });

          if (currentSegment) consolidated.push(currentSegment);

          //splitting any segments longer than quantum for visual display only
          const visuallySplitTimeline = [];
          consolidated.forEach((segment) => {
            if (segment.job !== null && segment.end - segment.start > quantum) {
              // Split into quantum-sized chunks for display
              let start = segment.start;
              while (start < segment.end) {
                const chunkEnd = Math.min(start + quantum, segment.end);
                visuallySplitTimeline.push({
                  start: start,
                  end: chunkEnd,
                  job: segment.job,
                  remaining: segment.remaining, //remaining time. disabled for now
                });
                start = chunkEnd;
              }
            } else {
              //small segments as-is
              visuallySplitTimeline.push(segment);
            }
          });

          return visuallySplitTimeline;
        });

        //get all scheduling points (quantum boundaries and job completions)
        const schedulingPoints = new Set();

        //add all job start/end times
        displayTimelines.forEach((timeline) => {
          timeline.forEach((segment) => {
            schedulingPoints.add(segment.start);
            schedulingPoints.add(segment.end);

            //add quantum boundaries to job segments
            if (segment.job !== null) {
              const firstQuantumPoint = segment.start + quantum;
              if (firstQuantumPoint < segment.end) {
                schedulingPoints.add(firstQuantumPoint);
              }

              //add following quantum boundaries
              let quantumPoint = firstQuantumPoint + quantum;
              while (quantumPoint < segment.end) {
                schedulingPoints.add(quantumPoint);
                quantumPoint += quantum;
              }
            }
          });
        });

        //filter points to only include queue states
        const sortedTimePoints = Array.from(schedulingPoints)
          .sort((a, b) => a - b)
          .filter((time) => {
            //fix for precision formatting
            return (
              queueStates[time.toFixed(2)] ||
              queueStates[time.toFixed(1)] ||
              queueStates[time.toString()]
            );
          });

        const maxTime = Math.max(...sortedTimePoints, 10);

        //scaling to fit timeline in window
        const maxAvailableWidth = Math.min(window.innerWidth * 0.85, 1200); //85% width with max 1200px
        const baseUnitWidth = 80; //for further window size customization
        const totalTimeWidth = maxTime * baseUnitWidth;
        const scaleFactor = Math.min(
          1,
          (maxAvailableWidth - 90) / totalTimeWidth
        ); //label area
        const scaledWidth = totalTimeWidth * scaleFactor;
        const scaledUnit = baseUnitWidth * scaleFactor;

        const labelAreaWidth = 90; //80px label + 10px padding

        //time ticks only at scheduling points (using scaled units)
        const timeTicksHTML = `
                  <div class="timeline-ticks" style="width: ${scaledWidth}px">
                      ${sortedTimePoints
                        .map(
                          (time) => `
                          <div class="tick" style="left: ${
                            time * scaledUnit
                          }px"></div>
                          <div class="tick-label" style="left: ${
                            time * scaledUnit
                          }px">${time.toFixed(1)}</div>
                      `
                        )
                        .join("")}
                  </div>`;

        const colors = [
          "#FF6B6B",
          "#4ECDC4",
          "#45B7D1",
          "#FFA07A",
          "#98D8C8",
          "#F67280",
          "#C06C84",
        ];

        //timeline visualization (using scaled units)
        //first it sets the bar build space
        //then for each segment that I put together before in the displayTimelines func make a subblock
        let timelineHTML = `
              <h3>CPU Utilization Timeline</h3>
              <div class="timeline-master-container">
                  <div class="timeline-scrollable-area">
                      <div class="timeline-outer-container" style="width: ${
                        scaledWidth + labelAreaWidth
                      }px">
                          <div class="timeline-content-container">
                              ${displayTimelines
                                .map(
                                  (timeline, cpuIndex) => `
                                  <div class="cpu-row">
                                      <div class="cpu-label">CPU ${
                                        cpuIndex + 1
                                      }:</div>
                                      <div class="cpu-bar-container" style="width: ${scaledWidth}px">
                                          <div class="cpu-bar">
                                              ${timeline
                                                .map((segment) => {
                                                  const width =
                                                    (segment.end -
                                                      segment.start) *
                                                    scaledUnit;
                                                  if (segment.job === null) {
                                                    return `<div class="time-block idle"
                                                          style="width: ${width}px; left: ${
                                                      segment.start * scaledUnit
                                                    }px"
                                                          title="Idle (${segment.start.toFixed(
                                                            1
                                                          )}-${segment.end.toFixed(
                                                      1
                                                    )})">
                                                          IO<div class="segment-end" style="left: ${width}px"></div>
                                                      </div>`;
                                                  } else {
                                                    return `<div class="time-block"
                                                          style="background-color: ${
                                                            colors[
                                                              segment.job %
                                                                colors.length
                                                            ]
                                                          };
                                                          width: ${width}px; left: ${
                                                      segment.start * scaledUnit
                                                    }px"
                                                          title="J${
                                                            segment.job
                                                          } (${segment.start.toFixed(
                                                      1
                                                    )}-${segment.end.toFixed(
                                                      1
                                                    )}) ${
                                                      segment.remaining < 0
                                                        ? "IO"
                                                        : ""
                                                    }">
                                                          J${segment.job}
                                                      </div>`;
                                                  }
                                                })
                                                .join("")}
                                          </div>
                                      </div>
                                  </div>
                              `
                                )
                                .join("")}
                          </div>
                          <div class="timeline-ticks-container" style="margin-left: ${
                            labelAreaWidth + 10
                          }px; width: ${scaledWidth}px">
                              ${(() => {
                                const placedReports = [];
                                return sortedTimePoints
                                  .map((time) => {
                                    const leftPos = time * scaledUnit;
                                    const reportHtml =
                                      getCombinedQueueReport(time);
                                    const reportWidth = scaledUnit * 1;

                                    //for overlaps with previous queue reports
                                    let verticalOffset = 0;
                                    const minHorizontalGap = scaledUnit * 0.4; //min space between reports
                                    for (const placed of placedReports) {
                                      const horizontalDistance = Math.abs(
                                        placed.left - leftPos
                                      );

                                      if (
                                        horizontalDistance <
                                        reportWidth + minHorizontalGap
                                      ) {
                                        verticalOffset = Math.max(
                                          verticalOffset,
                                          placed.offset + 30
                                        );
                                        //case: if reports are very close but not overlapping
                                        if (
                                          horizontalDistance >
                                          reportWidth * 0.4
                                        ) {
                                          verticalOffset = Math.min(
                                            verticalOffset,
                                            0
                                          ); //limit offset
                                        }
                                      }
                                    }
                                    placedReports.push({
                                      left: leftPos,
                                      offset: verticalOffset,
                                    });

                                    return `
                                      <div class="tick-group">

                                      <div class="tick" style="left: ${leftPos}px"></div>
                                      <div class="tick-label" style="left: ${leftPos}px">${time.toFixed(
                                      1
                                    )}</div>
                                      <div class="queue-report"
                                          style="left: ${leftPos}px; top: ${
                                      38 + verticalOffset
                                    }px"
                                          data-time="${time}"
                                          data-offset="${verticalOffset}">
                                          ${reportHtml}
                                      </div>
                                      </div>
                                      `;
                                  })
                                  .join("");
                              })()}
                          </div>
                      </div>
                  </div>
              </div>

              <style>
              .timeline-master-container {
                  width: 100%;
                  max-width: 100%;
                  margin: 0 auto;
                  min-height: ${displayTimelines.length * 55 + 60}px;
              }
              .timeline-scrollable-area {
                  overflow-x: auto;
                  width: 100%;
                  padding-bottom: 15px;
                  min-height: 300px;
              }
              .timeline-outer-container {
                  position: relative;
                  min-height: ${displayTimelines.length * 55 + 50}px;
                  width: ${scaledWidth + labelAreaWidth}px;
                  margin: 0;
                  padding: 0;
              }
              .timeline-content-container {
                  display: flex;
                  flex-direction: column;
                  margin-bottom: 0;
              }
              .cpu-row {
                  display: flex;
                  align-items: center;
                  margin-bottom: 5px;
                  height: 40px;
                  width: 100%;
              }
              .cpu-label {
                  width: ${labelAreaWidth}px;
                  padding-right: 10px;
                  text-align: right;
                  flex-shrink: 0;
              }
              .cpu-bar-container {
                  position: relative;
                  height: 40px;
                  width: ${scaledWidth}px;
                  flex-shrink: 0;
              }
              .timeline-ticks-container {
                  position: relative;
                  height: 30px;
                  width: ${scaledWidth}px;
                  margin-left: ${labelAreaWidth}px;
                  border-top: 1px solid #ccc;
              }
              .cpu-bar {
                  position: absolute;
                  height: 40px;
                  width: 100%;
                  background-color: #f0f0f0;
                  border-radius: 4px;
                  overflow: visible;
              }
              .time-block {
                  position: absolute;
                  display: flex;
                  align-items: center;
                  justify-content: center;
                  color: white;
                  font-weight: bold;
                  height: 40px;
                  border-left: 0.5px solid black;
                  border-right: 0.5px solid black;
                  transition: all 0.2s;
                  min-width: ${Math.max(20 * scaleFactor, 10)}px;
              }
              .time-block:hover {
                  transform: scale(1.05);
                  z-index: 1;
                  box-shadow: 0 0 5px rgba(0,0,0,0.3);
              }
              .time-block.idle {
                  background-color: #e0e0e0;
                  color: #333;
              }
              .tick {
                  position: absolute;
                  top: 0;
                  width: 1px;
                  height: 10px;
                  background-color: #333;
              }

              .tick-label {
                  position: absolute;
                  top: 12px;
                  transform: translateX(-50%);
                  font-size: 12px;
                  white-space: nowrap;
              }
              .tick-group {
                  display: inline-block;
              }
              .tick-group:hover .tick-label {
                  color: #0066cc;
                  font-weight: bold;
                  transform: translateX(-50%) scale(1.1);
                  z-index: 20;
              }

              .tick-group:hover .tick {

                  height: 15px;
                  background-color: #0066cc;
              }
              .queue-report {
                  position: absolute;
                  top: 15px;
                  z-index: 2;
                  left: 50%;
                  transform: translateX(-50%);
                  font-family: monospace;
                  font-size: 7px;
                  color: #333;
                  line-height: 1.2;
                  white-space: normal;
                  overflow: hidden;
                  text-overflow: ellipsis;
                  background: rgba(255, 255, 255, 0.95);
                  padding: 2px 4px;
                  border-radius: 2px;
                  max-width: ${scaledUnit * 2}px;
                  font-weight: bold;
                  z-index: 5;
                  transition: all 0.2s ease;
                  cursor: pointer;
                  border: 1px solid rgba(0,0,0,0.1);
              }
              .queue-report:hover {
                  z-index: 20;
                  background: white;
                  box-shadow: 0 0 5px rgba(0,0,0,0.3);
                  max-width: none;
                  white-space: normal;
                  overflow: visible;
                  transform: translateX(-50%) translateY(-5px);
              }
              .queue-report .queue-section,
              .queue-report .running-section {
                  display: block;
              }
              .queue-report .job-entry {
                  display: block;
                  margin: 0;
                  padding: 0;
                  white-space: nowrap;
              }
              .queue-report .queue-count {
                  font-size: 6px;
              }
              </style>
              `;

        //style comments here to not mess with style block format..
        //queue description not showing whole box when timeline becomes cluttered
        //added to styles: tick group(to synchronize queue description and time label hover),
        //queue report (to replace the previous queue description style), added hovers around
        //if the queue description gets hovered, then hover this too

        document.getElementById("executionTimeline").innerHTML = timelineHTML;

        function getCombinedQueueReport(time) {
          const state =
            queueStates[time.toFixed(2)] ||
            queueStates[time.toFixed(1)] ||
            queueStates[time.toString()];

          if (!state) return "";

          // Format queue jobs (only non-zero remaining)
          const queueJobs =
            state.queue && state.queue.length > 0
              ? state.queue
                  .filter((j) => j.remaining > 0)
                  .map(
                    (j) =>
                      `<div class="job-entry">J${j.id} ${j.remaining.toFixed(
                        1
                      )}</div>`
                  )
                  .join("")
              : "";

          // Format running jobs (only non-zero remaining)
          const runningJobs =
            state.running && state.running.length > 0
              ? state.running
                  .filter((j) => j.remaining > 0)
                  .map(
                    (j) =>
                      `<div class="job-entry running-job">J${
                        j.id
                      } ${j.remaining.toFixed(1)}</div>`
                  )
                  .join("")
              : "";

          // Determine if we should show empty marker
          const showEmptyMarker =
            (!queueJobs || queueJobs.length === 0) &&
            (!runningJobs || runningJobs.length === 0);

          return `
              ${
                queueJobs
                  ? queueJobs
                  : runningJobs
                  ? ""
                  : '<div class="job-entry">[]</div>'
              }
              ${runningJobs}
          `;
        }
      }

      // Initialize with 2 jobs when page loads
      window.onload = function () {
        addJob();
        addJob();
      };
    </script>
  </body>
</html>
