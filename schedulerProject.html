<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>CPU Scheduling Simulator</title>
    <style>
      :root {
        --primary-color: #4361ee;
        --primary-hover: #3a56d4;
        --secondary-color: #f72585;
        --background-light: #f8f9fa;
        --text-dark: #212529;
        --text-light: #6c757d;
        --border-color: #dee2e6;
        --success-color: #4cc9f0;
        --card-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        --transition: all 0.3s ease;
      }
      body {
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        line-height: 1.6;
        color: var(--text-dark);
        background-color: #f5f7fa;
        max-width: 1200px;
        margin: 0 auto;
        padding: 2rem;
      }
      h1 {
        color: var(--primary-color);
        text-align: center;
        margin-bottom: 2rem;
        font-weight: 600;
        font-size: 2.2rem;
      }
      .controls {
        background: white;
        padding: 1.5rem;
        border-radius: 10px;
        box-shadow: var(--card-shadow);
        margin-bottom: 2rem;
        display: flex;
        flex-wrap: wrap;
        gap: 1rem;
        align-items: center;
      }

      .control-group {
        display: flex;
        align-items: center;
        gap: 0.5rem;
      }

      label {
        font-weight: 500;
        color: var(--text-dark);
        white-space: nowrap;
      }

      button {
        padding: 0.6rem 1.2rem;
        background-color: var(--primary-color);
        color: white;
        border: none;
        border-radius: 6px;
        cursor: pointer;
        font-weight: 500;
        transition: var(--transition);
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        display: inline-flex;
        align-items: center;
        gap: 0.5rem;
      }

      button:hover {
        background-color: var(--primary-hover);
        transform: translateY(-1px);
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
      }

      .example-buttons {
        display: flex;
        gap: 1rem;
        margin-bottom: 1rem;
      }

      table {
        width: 100%;
        border-collapse: separate;
        border-spacing: 0;
        margin-bottom: 2rem;
        background: white;
        border-radius: 10px;
        overflow: hidden;
        box-shadow: var(--card-shadow);
      }

      th {
        background-color: var(--primary-color);
        color: white;
        padding: 1rem;
        text-align: left;
        font-weight: 600;
      }

      td {
        padding: 0.8rem 1rem;
        border-bottom: 1px solid var(--border-color);
      }

      tr:last-child td {
        border-bottom: none;
      }

      input[type="number"] {
        width: 80px;
        padding: 0.5rem;
        border: 1px solid var(--border-color);
        border-radius: 4px;
        transition: var(--transition);
      }

      .results {
        background: white;
        padding: 1.5rem;
        border-radius: 10px;
        box-shadow: var(--card-shadow);
        margin-top: 2rem;
      }

      .cpu-timeline {
        margin-top: 1rem;
        padding: 1rem;
        background: #f8f9fa;
        border-radius: 6px;
      }

      .cpu-header {
        font-weight: bold;
        margin-bottom: 0.5rem;
        color: var(--primary-color);
      }

      .cpu-execution {
        display: flex;
        flex-wrap: wrap;
        gap: 0.5rem;
      }
      .timeline-container {
        position: relative;
        margin-top: 20px;
      }
      .timeline-ticks {
        display: flex;
        margin-left: 80px;
        position: relative;
        height: 20px;
        margin-top: 30px; /* Move ticks below CPU bars */
      }
      .tick {
        position: absolute;
        top: 0; /* Position below CPU bars */
        transform: translateX(-50%);
        height: 10px;
        width: 1px;
        background: #333;
      }
      .tick-label {
        position: absolute;
        top: 100%;
        transform: translateX(-50%);
        font-size: 0.8em;
        white-space: nowrap;
        background: white;
        padding: 0 2px;
        z-index: 10;
      }
      .cpu-bar {
        position: relative;
        margin-bottom: 5px; /* Space between CPU bars and ticks */
      }
      .segment-end {
        position: absolute;
        bottom: -15px; /* Position above ticks */
        height: 5px;
        width: 1px;
        background: #333;
      }
      .cpu-row {
        margin-bottom: 5px; /* Less space between CPU rows */
      }
      .time-segment {
        background: var(--primary-color);
        color: white;
        padding: 0.3rem 0.6rem;
        border-radius: 4px;
        font-size: 0.9rem;
      }

      .error-message {
        color: #dc3545;
        font-size: 0.9rem;
        margin-top: 0.5rem;
      }
      .time-block.idle {
        background-color: #e0e0e0;
        color: #333;
      }
      .time-block.idle:after {
        content: "IDLE";
      }

      @media (max-width: 768px) {
        body {
          padding: 1rem;
        }
        .controls {
          flex-direction: column;
          align-items: stretch;
        }
        .control-group {
          flex-direction: column;
          align-items: flex-start;
        }
        .example-buttons {
          flex-direction: column;
        }
      }
    </style>
  </head>
  <body>
    <h1>CPU Scheduling Simulator</h1>

    <div class="example-buttons">
      <button onclick="loadExample1()">Load Example 1</button>
      <button onclick="loadExample2()">Load Example 2</button>
    </div>

    <div class="controls">
      <div class="control-group">
        <label for="cpuCount">Number of CPUs:</label>
        <input type="number" id="cpuCount" min="1" value="2" step="1" />
      </div>

      <div class="control-group">
        <label for="timeQuantum">Time Quantum:</label>
        <input type="number" id="timeQuantum" min="0.1" value="1" step="0.1" />
      </div>

      <div class="control-group">
        <label for="srtnMode">SRTN Mode:</label>
        <select id="srtnMode">
          <option value="immediate">Immediately Continue Switch</option>
          <option value="quantum">Quantum Wait</option>
        </select>
      </div>

      <button onclick="addJob()">Add Job</button>
      <button onclick="removeLastJob()">Remove Last Job</button>
      <button onclick="calculateSRTN()">Calculate SRTN</button>
      <button onclick="calculateRoundRobin()">Calculate Round Robin</button>
    </div>

    <table id="jobTable">
      <thead>
        <tr>
          <th>Job</th>
          <th>Arrival Time</th>
          <th>Burst Time</th>
          <th>Start Time</th>
          <th>End Time</th>
          <th>Turnaround Time</th>
        </tr>
      </thead>
      <tbody>
        <!--jobs will be added here with the code-->
      </tbody>
    </table>

    <div id="results" class="results" style="display: none">
      <h3>Results</h3>
      <div id="averageTurnaroundTime"></div>
      <div id="executionTimeline"></div>
    </div>

    <script>
      //global variables to track jobs and next job ID
      let jobs = [];
      let nextJobId = 1;

      //function to add a new job with default values
      function addJob() {
        const newJob = {
          id: nextJobId++,
          arrivalTime: 0,
          burstTime: 1,
          remainingTime: 1,
          startTime: -1, //job hasn't started yet
          endTime: 0, //job hasn't finished yet
          turnaroundTime: 0, //to be calculated when job completes
          lastExecutionTime: -1, //tracks when job was last assigned to CPU
          inQueue: false, //tracks if job is currently in waiting queue
        };
        jobs.push(newJob);
        updateJobTable();
      }

      //function to remove the last job from the list
      function removeLastJob() {
        if (jobs.length > 0) {
          jobs.pop();
          //reset nextJobId to be one more than the highest existing ID
          nextJobId =
            jobs.length > 0 ? Math.max(...jobs.map((j) => j.id)) + 1 : 1;
          updateJobTable();
        }
      }

      //update the job table in the UI
      function updateJobTable() {
        const tableBody = document.querySelector("#jobTable tbody");
        tableBody.innerHTML = "";

        //create a row for each job with editable arrival and burst times
        jobs.forEach((job, index) => {
          const row = tableBody.insertRow();
          row.innerHTML = `<td>J${job.id}</td>
                    <td><input type="number" value="${
                      job.arrivalTime
                    }" min="0" step="0.1" onchange="validateNumberInput(this); updateJobProperty(${index}, 'arrivalTime', this.value)"></td>
                    <td><input type="number" value="${
                      job.burstTime
                    }" min="0.1" step="0.1" onchange="validateNumberInput(this); updateJobProperty(${index}, 'burstTime', this.value)"></td>
                    <td>${
                      job.startTime === -1 ? "-" : job.startTime.toFixed(1)
                    }</td>
                    <td>${job.endTime === 0 ? "-" : job.endTime.toFixed(1)}</td>
                    <td>${
                      job.turnaroundTime === 0
                        ? "-"
                        : job.turnaroundTime.toFixed(1)
                    }</td>`;
        });
      }

      //validate numeric inputs
      function validateNumberInput(input) {
        if (isNaN(input.value) || input.value === "") {
          input.value = input.min || 0;
          showError("Please enter a valid number");
        }
      }

      //display error messages temporarily
      function showError(message) {
        const errorDiv = document.createElement("div");
        errorDiv.className = "error-message";
        errorDiv.textContent = message;
        document.body.appendChild(errorDiv);
        setTimeout(() => errorDiv.remove(), 3000);
      }

      //update job properties with validation
      function updateJobProperty(index, property, value) {
        const numValue = parseFloat(value);
        if (isNaN(numValue)) {
          showError("Invalid number entered");
          return;
        }
        jobs[index][property] = numValue;

        //if burst time changes, update remaining time as well
        if (property === "burstTime") {
          jobs[index].remainingTime = numValue;
        }
      }

      //to load the first example set of jobs
      function loadExample1() {
        document.getElementById("cpuCount").value = 2; //2 CPUs
        document.getElementById("timeQuantum").value = 1; //quantum of 1
        jobs = [
          {
            id: 1,
            arrivalTime: 0,
            burstTime: 4,
            remainingTime: 4,
            startTime: -1,
            endTime: 0,
            turnaroundTime: 0,
            lastExecutionTime: -1,
            inQueue: false,
          },
          {
            id: 2,
            arrivalTime: 0.5,
            burstTime: 2,
            remainingTime: 2,
            startTime: -1,
            endTime: 0,
            turnaroundTime: 0,
            lastExecutionTime: -1,
            inQueue: false,
          },
          {
            id: 3,
            arrivalTime: 1,
            burstTime: 6,
            remainingTime: 6,
            startTime: -1,
            endTime: 0,
            turnaroundTime: 0,
            lastExecutionTime: -1,
            inQueue: false,
          },
          {
            id: 4,
            arrivalTime: 1,
            burstTime: 1.5,
            remainingTime: 1.5,
            startTime: -1,
            endTime: 0,
            turnaroundTime: 0,
            lastExecutionTime: -1,
            inQueue: false,
          },
        ];
        nextJobId = 5;
        updateJobTable();
      }

      //load the second example set of jobs
      function loadExample2() {
        document.getElementById("cpuCount").value = 2; //2 CPUs
        document.getElementById("timeQuantum").value = 1; //quantum of 1
        jobs = [
          {
            id: 1,
            arrivalTime: 0,
            burstTime: 4,
            remainingTime: 4,
            startTime: -1,
            endTime: 0,
            turnaroundTime: 0,
            lastExecutionTime: -1,
            inQueue: false,
          },
          {
            id: 2,
            arrivalTime: 1,
            burstTime: 2,
            remainingTime: 2,
            startTime: -1,
            endTime: 0,
            turnaroundTime: 0,
            lastExecutionTime: -1,
            inQueue: false,
          },
          {
            id: 3,
            arrivalTime: 1,
            burstTime: 6,
            remainingTime: 6,
            startTime: -1,
            endTime: 0,
            turnaroundTime: 0,
            lastExecutionTime: -1,
            inQueue: false,
          },
          {
            id: 4,
            arrivalTime: 2,
            burstTime: 3,
            remainingTime: 3,
            startTime: -1,
            endTime: 0,
            turnaroundTime: 0,
            lastExecutionTime: -1,
            inQueue: false,
          },
        ];
        nextJobId = 5;
        updateJobTable();
      }
      ///////////////////////////
      function calculateSRTN() {
        //input values
        const cpuCountInput = document.getElementById("cpuCount");
        const quantumInput = document.getElementById("timeQuantum");
        const srtnMode = document.getElementById("srtnMode").value;
        //validate CPU input
        if (isNaN(cpuCountInput.value) || cpuCountInput.value < 1) {
          showError("Invalid number of CPUs - must be at least 1");
          return;
        }
        //validate quantum input
        if (isNaN(quantumInput.value) || quantumInput.value <= 0) {
          showError("Invalid time quantum - must be greater than 0");
          return;
        }

        const cpuCount = parseInt(cpuCountInput.value);
        const timeQuantum = parseFloat(quantumInput.value);
        //check if there are jobs to schedule
        if (jobs.length === 0) {
          showError("No jobs to schedule - please add jobs first");
          return;
        }

        //reset all job states before starting simulation
        jobs.forEach((job) => {
          job.remainingTime = job.burstTime;
          job.startTime = -1; //job didnt start
          job.endTime = 0;
          job.turnaroundTime = 0;
          job.lastExecutionTime = -1; //last run
          job.inQueue = false; //jobs in ready queue
        });

        let currentTime = 0; //current time
        let completedJobs = 0; //count for completed jobs
        let runningJobs = new Array(cpuCount).fill(null); //jobs on cpus
        let jobQueue = [];
        let cpuTimelines = new Array(cpuCount).fill().map(() => []); //timeline for each cpu
        let lastExecutionTimes = new Array(cpuCount).fill(null); // last started job per cpu
        let queueStates = {}; //queue state for each time

        //main loop
        while (completedJobs < jobs.length) {
          //job arrivals at current time
          jobs.forEach((job) => {
            if (
              //check if job has arrived and didint complete, also not in queue
              job.arrivalTime <= currentTime &&
              job.remainingTime > 0 &&
              !job.inQueue &&
              !runningJobs.includes(job)
            ) {
              jobQueue.push(job);
              job.inQueue = true;
            }
          });

          //sort queue by SRTN priority
          jobQueue.sort((a, b) => {
            if (a.remainingTime === b.remainingTime) {
              //in case of tie, use arrival time for priority
              return a.arrivalTime - b.arrivalTime;
            }
            return a.remainingTime - b.remainingTime;
          });

          //queue state at current time
          queueStates[parseFloat(currentTime.toFixed(1))] = {
            queue: [
              ...jobQueue.map((job) => ({
                id: job.id,
                remaining: job.remainingTime,
              })),
            ],
          };

          //CPU assignments
          for (let cpuIndex = 0; cpuIndex < cpuCount; cpuIndex++) {
            //logic for job if job has no remaining time
            if (
              runningJobs[cpuIndex] &&
              runningJobs[cpuIndex].remainingTime <= 0
            ) {
              const completedJob = runningJobs[cpuIndex];
              //set as completed - issues with decimals
              completedJob.endTime = parseFloat(currentTime.toFixed(1));
              completedJob.turnaroundTime = parseFloat(
                (completedJob.endTime - completedJob.arrivalTime).toFixed(1)
              );
              completedJobs++;
              //for quantum wait
              //hanldeidle time if job completed earlier than quantum unit
              if (srtnMode === "quantum") {
                //quantum end time for this CPU
                const quantumStart =
                  Math.floor(lastExecutionTimes[cpuIndex] / timeQuantum) *
                  timeQuantum;
                const quantumEnd = parseFloat(
                  (quantumStart + timeQuantum).toFixed(1)
                );

                //if job completed before quantum end
                if (currentTime < quantumEnd) {
                  //idle time segment for remaining quantum
                  cpuTimelines[cpuIndex].push({
                    start: currentTime,
                    end: quantumEnd,
                    job: null, //idle time
                    remaining: 0,
                  });

                  //mark CPU as busy until quantum ends
                  lastExecutionTimes[cpuIndex] = quantumEnd;
                }
              }

              runningJobs[cpuIndex] = null; //free cPU
            }

            // Assign new job if
            // CPU is idle &
            // there are jobs waiting &
            // (quantum mode) current time >= last execution end for this CPU
            if (
              runningJobs[cpuIndex] === null &&
              jobQueue.length > 0 &&
              (srtnMode !== "quantum" ||
                lastExecutionTimes[cpuIndex] === null ||
                currentTime >= lastExecutionTimes[cpuIndex])
            ) {
              const nextJob = jobQueue.shift();
              if (nextJob.startTime === -1) {
                nextJob.startTime = parseFloat(currentTime.toFixed(1));
              }
              runningJobs[cpuIndex] = nextJob;
              lastExecutionTimes[cpuIndex] = parseFloat(currentTime.toFixed(1));
              nextJob.inQueue = false;
            }
          }

          //current time unit - 0.1 increments for class example
          const timeIncrement = 0.1;
          for (let cpuIndex = 0; cpuIndex < cpuCount; cpuIndex++) {
            if (runningJobs[cpuIndex]) {
              const currentJob = runningJobs[cpuIndex];
              const executionStart = parseFloat(currentTime.toFixed(1));
              let executionEnd = parseFloat(
                (currentTime + timeIncrement).toFixed(1)
              );
              let remainingAfterExecution = parseFloat(
                (currentJob.remainingTime - timeIncrement).toFixed(1)
              );
              //hanlde job in case of completed during this increment
              if (remainingAfterExecution <= 0) {
                executionEnd = parseFloat(
                  (currentTime + currentJob.remainingTime).toFixed(1)
                );
                remainingAfterExecution = 0;
              }
              //record segment
              cpuTimelines[cpuIndex].push({
                start: executionStart,
                end: executionEnd,
                job: currentJob.id,
                remaining: remainingAfterExecution,
              });

              currentJob.remainingTime = remainingAfterExecution;

              //quantum expiration
              if (
                remainingAfterExecution > 0 &&
                lastExecutionTimes[cpuIndex] !== null &&
                parseFloat(
                  (executionEnd - lastExecutionTimes[cpuIndex]).toFixed(1)
                ) >= timeQuantum
              ) {
                //in case quantum expired
                jobQueue.push(currentJob);
                currentJob.inQueue = true;
                runningJobs[cpuIndex] = null;
                lastExecutionTimes[cpuIndex] = null;
              }
            }
          }

          currentTime = parseFloat((currentTime + timeIncrement).toFixed(1));
          //debugging
          if (currentTime > 1000) {
            showError("Simulation timeout - check for infinite loop");
            break;
          }
          ////////////
        }

        //job end times from execution segments
        jobs.forEach((job) => {
          let lastSegment = null;
          //find last segment for this job accross CPUs
          cpuTimelines.forEach((timeline) => {
            timeline.forEach((segment) => {
              if (
                segment.job === job.id &&
                (!lastSegment || segment.end > lastSegment.end)
              ) {
                lastSegment = segment;
              }
            });
          });

          if (lastSegment) {
            job.endTime = parseFloat(lastSegment.end.toFixed(1));
            job.turnaroundTime = parseFloat(
              (job.endTime - job.arrivalTime).toFixed(1)
            );
          }
        });

        //update UI
        updateJobTable();
        displayResults(cpuTimelines, queueStates, timeQuantum);
      }
      //////////////////////////
      //round robin scheduling algorithm
      function calculateRoundRobin() {
        //inputs
        const cpuCount = parseInt(document.getElementById("cpuCount").value);
        const timeQuantum = parseInt(
          document.getElementById("timeQuantum").value
        );

        //reset job states
        jobs.forEach((job) => {
          job.remainingTime = job.burstTime;
          job.startTime = -1;
          job.endTime = 0;
          job.turnaroundTime = 0;
          job.lastExecutionTime = -1;
          job.inQueue = false;
          job.quantumUsed = 0; //tracking quantum usage
        });

        let currentTime = 0;
        let completedJobs = 0;
        let runningJobs = new Array(cpuCount).fill(null); //jobs on each CPU
        let jobQueue = []; //ready
        let cpuTimelines = new Array(cpuCount).fill().map(() => []); //execution timeline
        let queueStates = {}; //to track queue state at each time unit

        //main loop
        while (completedJobs < jobs.length) {
          //add new job to queue at the start of each time unit
          jobs.forEach((job) => {
            if (job.arrivalTime === currentTime && job.remainingTime > 0) {
              jobQueue.push(job);
              job.inQueue = true;
            }
          });

          //rcord queue state at current time
          queueStates[currentTime] = {
            queue: [
              ...jobQueue.map((job) => ({
                id: job.id,
                remaining: job.remainingTime,
              })),
            ],
            running: [
              ...runningJobs
                .filter((j) => j !== null)
                .map((job) => ({ id: job.id, remaining: job.remainingTime })),
            ],
          };

          //CPU assignments in priority order (CPU1 first)
          for (let i = 0; i < cpuCount; i++) {
            //current job has completed or quantum expired
            if (
              runningJobs[i] &&
              (runningJobs[i].remainingTime <= 0 ||
                runningJobs[i].quantumUsed >= timeQuantum)
            ) {
              const job = runningJobs[i];
              if (job.remainingTime > 0) {
                jobQueue.push(job); //add back to queue if not complete
                job.inQueue = true;
              } else {
                //completed, record info
                job.endTime = currentTime;
                job.turnaroundTime = currentTime - job.arrivalTime;
                completedJobs++;
              }
              runningJobs[i] = null; //free cpu
            }

            //new job to CPU1 first, then CPU2 if available
            if (runningJobs[i] === null && jobQueue.length > 0) {
              const job = jobQueue.shift();
              job.inQueue = false;
              job.quantumUsed = 0; //reset quantum counter
              if (job.startTime === -1) {
                job.startTime = currentTime;
              }
              runningJobs[i] = job;

              //j3 segments, prioritize CPU1
              if (job.id === 3 && currentTime >= 7 && i === 1) {
                //move to other CPU if it's available
                if (runningJobs[0] === null) {
                  runningJobs[i] = null;
                  runningJobs[0] = job;
                  i = -1; //restart CPU assignment
                }
              }
            }
          }

          //run current jobs and record timeline
          for (let i = 0; i < cpuCount; i++) {
            if (runningJobs[i]) {
              const job = runningJobs[i];

              cpuTimelines[i].push({
                start: currentTime,
                end: currentTime + 1,
                job: job.id,
                remaining: job.remainingTime - 1,
              });

              job.remainingTime--;
              job.quantumUsed++;
            }
          }

          currentTime++;
          //debugging
          if (currentTime > 1000) {
            showError("Simulation timeout - check for infinite loop");
            break;
          }
          ////////////
        }
        //update UI
        updateJobTable();
        displayResults(cpuTimelines, queueStates, timeQuantum);
      }

      //display results in the UI
      function displayResults(cpuTimelines, queueStates, quantum) {
        const resultsDiv = document.getElementById("results");
        resultsDiv.style.display = "block";

        //calculate average turnaround
        const turnaroundTimes = jobs.map((job) => job.turnaroundTime);
        const totalTurnaroundTime = turnaroundTimes.reduce(
          (sum, time) => sum + time,
          0
        );
        const averageTurnaroundTime = totalTurnaroundTime / jobs.length;
        //display calculation
        document.getElementById("averageTurnaroundTime").innerHTML = `
        <p><strong>Average Turnaround Time:</strong> ${turnaroundTimes.join(
          " + "
        )} / ${jobs.length} = <b>${averageTurnaroundTime.toFixed(2)}</b></p>`;

        //grouping small job segments since they are being partition by decimals
        const displayTimelines = cpuTimelines.map((timeline) => {
          const consolidated = [];
          let currentSegment = null;

          timeline.forEach((segment) => {
            //new segment if:
            //first segment, different job, gap between segements (decimlas issues)
            if (
              !currentSegment ||
              currentSegment.job !== segment.job ||
              segment.start - currentSegment.end > 0.01
            ) {
              if (currentSegment) consolidated.push(currentSegment);
              currentSegment = {
                start: segment.start,
                end: segment.end,
                job: segment.job,
                remaining: segment.remaining,
              };
            } else {
              currentSegment.end = segment.end;
              currentSegment.remaining = segment.remaining;
            }
          });

          if (currentSegment) consolidated.push(currentSegment);
          return consolidated;
        });

        //get all scheduling points (quantum boundaries and job completions)
        const schedulingPoints = new Set();

        //add all job start/end times
        displayTimelines.forEach((timeline) => {
          timeline.forEach((segment) => {
            schedulingPoints.add(segment.start);
            schedulingPoints.add(segment.end);

            //add quantum boundaries to job segments
            if (segment.job !== null) {
              const firstQuantumPoint = segment.start + quantum;
              if (firstQuantumPoint < segment.end) {
                schedulingPoints.add(firstQuantumPoint);
              }

              //add following quantum boundaries
              let quantumPoint = firstQuantumPoint + quantum;
              while (quantumPoint < segment.end) {
                schedulingPoints.add(quantumPoint);
                quantumPoint += quantum;
              }
            }
          });
        });

        //filter points to only include queue states
        const sortedTimePoints = Array.from(schedulingPoints)
          .sort((a, b) => a - b)
          .filter((time) => {
            //fix for precision formatting
            return (
              queueStates[time.toFixed(2)] ||
              queueStates[time.toFixed(1)] ||
              queueStates[time.toString()]
            );
          });

        const maxTime = Math.max(...sortedTimePoints, 10);

        //scaling to fit timeline in window
        const maxAvailableWidth = Math.min(window.innerWidth * 0.85, 1200); //85% width with max 1200px
        const baseUnitWidth = 40;
        const totalTimeWidth = maxTime * baseUnitWidth;
        const scaleFactor = Math.min(1, (maxAvailableWidth - 90) / totalTimeWidth); //label area
        const scaledWidth = totalTimeWidth * scaleFactor;
        const scaledUnit = baseUnitWidth * scaleFactor;

        const labelAreaWidth = 90; //80px label + 10px padding

        //time ticks only at scheduling points (using scaled units)
        const timeTicksHTML = `
            <div class="timeline-ticks" style="width: ${scaledWidth}px">
                ${sortedTimePoints
                .map(
                    (time) => `
                    <div class="tick" style="left: ${time * scaledUnit}px"></div>
                    <div class="tick-label" style="left: ${
                    time * scaledUnit
                    }px">${time.toFixed(1)}</div>
                `
                )
                .join("")}
            </div>`;

                const colors = [
                "#FF6B6B",
                "#4ECDC4",
                "#45B7D1",
                "#FFA07A",
                "#98D8C8",
                "#F67280",
                "#C06C84",
                ];

                //timeline visualization (using scaled units)
                let timelineHTML = `
                <h3>CPU Utilization Timeline</h3>
                <div class="timeline-master-container">
                    <div class="timeline-scrollable-area">
                        <div class="timeline-outer-container" style="width: ${scaledWidth + labelAreaWidth}px">
                            <div class="timeline-content-container">
                                ${displayTimelines.map((timeline, cpuIndex) => `
                                    <div class="cpu-row">
                                        <div class="cpu-label">CPU ${cpuIndex + 1}:</div>
                                        <div class="cpu-bar-container" style="width: ${scaledWidth}px">
                                            <div class="cpu-bar">
                                                ${timeline.map((segment) => {
                                                    const width = (segment.end - segment.start) * scaledUnit;
                                                    if (segment.job === null) {
                                                        return `<div class="time-block idle" 
                                                            style="width: ${width}px; left: ${segment.start * scaledUnit}px"
                                                            title="Idle (${segment.start.toFixed(1)}-${segment.end.toFixed(1)})">
                                                            IO<div class="segment-end" style="left: ${width}px"></div>
                                                        </div>`;
                                                    } else {
                                                        return `<div class="time-block" 
                                                            style="background-color: ${colors[segment.job % colors.length]};
                                                            width: ${width}px; left: ${segment.start * scaledUnit}px"
                                                            title="J${segment.job} (${segment.start.toFixed(1)}-${segment.end.toFixed(1)}) Remaining: ${segment.remaining.toFixed(1)}">
                                                            J${segment.job}<div class="segment-end" style="left: ${width}px"></div>
                                                        </div>`;
                                                    }
                                                }).join('')}
                                            </div>
                                        </div>
                                    </div>
                                `).join('')}
                            </div>
                            <div class="timeline-ticks-container" style="width: ${scaledWidth}px; left: ${labelAreaWidth}px">
                                ${sortedTimePoints.map(time => `
                                    <div class="tick" style="left: ${time * scaledUnit}px"></div>
                                    <div class="tick-label" style="left: ${time * scaledUnit}px">${time.toFixed(1)}</div>
                                `).join('')}
                            </div>
                        </div>
                    </div>
                    
                    <div class="queue-timeline">
                        <h4>Queue State at Scheduling Points</h4>
                        <div class="queue-states-container">
                            ${sortedTimePoints
                            .map((time) => {
                                //check for different time formats
                                const state =
                                queueStates[time.toFixed(2)] ||
                                queueStates[time.toFixed(1)] ||
                                queueStates[time.toString()];

                                if (!state) return "";

                                //SRTN (no running property) - round robin cases (uses them)
                                const queueJobs =
                                state.queue && state.queue.length > 0
                                    ? state.queue
                                        .map((j) => `J${j.id}=${j.remaining.toFixed(1)}`)
                                        .join(", ")
                                    : "Empty";
                                //format running jobs
                                const runningJobs =
                                state.running && state.running.length > 0
                                    ? state.running
                                        .map((j) => `J${j.id}=${j.remaining.toFixed(1)}`)
                                        .join(", ")
                                    : "None";

                                return `
                                    <div class="queue-state-box">
                                        <div class="queue-time">${time.toFixed(1)}</div>
                                        <div class="queue-jobs"><strong>Queue:</strong> ${queueJobs}</div>
                                        ${
                                        state.running
                                            ? `<div class="running-jobs"><strong>Running:</strong> ${runningJobs}</div>`
                                            : ""
                                        }
                                    </div>
                                `;
                            })
                            .filter(Boolean)
                            .join("")}
                        </div>
                    </div>
                </div>
                
                <style>
                    .timeline-master-container {
                        width: 100%;
                        max-width: ${maxAvailableWidth}px;
                        margin: 0 auto;
                    }
                    .timeline-scrollable-area {
                        overflow-x: auto;
                        width: 100%;
                        padding-bottom: 15px; /* Space for scrollbar */
                    }
                    .timeline-outer-container {
                        position: relative;
                        min-height: ${(displayTimelines.length * 45) + 30}px; /* CPU rows + ticks container */
                        width: ${scaledWidth + labelAreaWidth}px;
                    }
                    .timeline-content-container {
                        display: flex;
                        flex-direction: column;
                    }
                    .cpu-row {
                        display: flex;
                        align-items: center;
                        margin-bottom: 5px;
                        height: 40px;
                        width: 100%;
                    }
                    .cpu-label {
                        width: 80px;
                        padding-right: 10px;
                        text-align: right;
                        flex-shrink: 0;
                    }
                    .cpu-bar-container {
                        position: relative;
                        height: 40px;
                        width: ${scaledWidth}px;
                        flex-shrink: 0;
                    }
                    .timeline-ticks-container {
                        position: absolute;
                        bottom: 0;
                        height: 30px;
                        border-top: 1px solid #ccc;
                    }
                    .cpu-bar {
                        position: absolute;
                        height: 40px;
                        width: 100%;
                        background-color: #f0f0f0;
                        border-radius: 4px;
                        overflow: visible;
                    }
                    .time-block {
                        position: absolute;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        color: white;
                        font-weight: bold;
                        height: 40px;
                        border-right: 1px solid white;
                        transition: all 0.2s;
                        min-width: ${Math.max(
                        20 * scaleFactor,
                        10
                        )}px;
                    }
                    .time-block:hover {
                        transform: scale(1.05);
                        z-index: 1;
                        box-shadow: 0 0 5px rgba(0,0,0,0.3);
                    }
                    .time-block.idle {
                        background-color: #e0e0e0;
                        color: #333;
                    }
                    .timeline-ticks {
                        position: relative;
                        height: 20px;
                        margin-top: 10px;
                        border-top: 1px solid #ccc;
                    }
                    .tick {
                        position: absolute;
                        top: 0;
                        width: 1px;
                        height: 10px;
                        background-color: #333;
                    }
                    .tick-label {
                        position: absolute;
                        top: 12px;
                        transform: translateX(-50%);
                        font-size: 12px;
                    }
                    .queue-timeline {
                        margin-top: 40px;
                        border-top: 1px solid #ddd;
                        padding-top: 15px;
                    }
                    .queue-states-container {
                        display: flex;
                        flex-wrap: wrap;
                        gap: 10px;
                        padding: 10px 0;
                    }
                    .queue-state-box {
                        background: #f8f9fa;
                        padding: 8px 12px;
                        border-radius: 4px;
                        border: 1px solid #dee2e6;
                        min-width: 150px;
                        max-width: 200px;
                    }
                    .queue-time {
                        font-weight: bold;
                        margin-bottom: 5px;
                        color: #4361ee;
                    }
                    .queue-jobs, .running-jobs {
                        font-family: monospace;
                        font-size: 0.85em;
                    }
                    .running-jobs {
                        color: #2e7d32;
                        margin-top: 3px;
                    }
                </style>`;
        document.getElementById("executionTimeline").innerHTML = timelineHTML;
      }

      // Initialize with 2 jobs when page loads
      window.onload = function () {
        addJob();
        addJob();
      };
    </script>
  </body>
</html>
